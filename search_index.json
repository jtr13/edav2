[["index.html", "edav.info, 2nd edition Chapter 1 Welcome!", " edav.info, 2nd edition Joyce Robbins 2022-02-17 Chapter 1 Welcome! This is the brand new start of edav.info 2.0! The first version of edav.info is still available, but will no longer be updated. With this resource, we try to give you a curated collection of tools and references that will make it easier to learn how to work with data in R. Detailed Examples will also be used to show proper exploratory data analysis under different circumstances. This resource is specifically tailored to the GR5293 Statistical Graphics and GR5702 Exploratory Data Analysis and Visualization courses offered at Columbia University. However, we hope that anyone interested in working with data in R will benefit from these pages. Happy coding! (Note. edav.info 2.0 is still under construction, and we will try our best to update new chapters weekly so that it will be up-to-date with the information you need to complete the current problem set.) "],["getting-started.html", "Chapter 2 Getting started 2.1 Top 10 essentials checklist 2.2 Troubleshooting 2.3 Tips &amp; tricks", " Chapter 2 Getting started Welcome to the world of EDAV! As you have already known, we will mainly use R through out the course. In an effort to get everyone on the same page, here is a checklist of essentials so you can get up and running. The best resources are scattered in different places online, so bear with links to various sites depending on the topic. 2.1 Top 10 essentials checklist (r4ds = R for Data Science by Garrett Grolemund and Hadley Wickham, free online) Install R (r4ds) – You need to have this installed but you won’t open the application since you’ll be working in RStudio. If you already installed R, make sure you’re current! The latest version of R (as of 2022-01-18) is R 4.1.2 “Bird Hippie” released on 2021/11/01. Install RStudio (r4ds) – Download the free, Desktop version for your OS. Working in this IDE will make working in R much more enjoyable. As with R, stay current. RStudio is constantly adding new features. The latest version (as of 2022-01-18) is RStudio 2021.09.2+382 (“Ghost Orchid”) release notes. Get comfortable with RStudio – In this chapter of Bruno Rodriguez’s Modern R with the Tidyverse, you’ll learn about panes, options, getting help, keyboard shortcuts, projects, add-ins, and packages. Be sure to try out: Do some math in the console Create an R Markdown file (.Rmd) and render it to .html Install some packages like tidyverse or MASS Another great option for learning the IDE: Watch Writing Code in RStudio (RStudio webinar) Learn “R Nuts and Bolts” – Roger Peng’s chapter in R Programming will give you a solid foundation in the basic building blocks of R. It’s worth making the investing in understanding how R objects work now so they don’t cause you problems later. Focus on vectors and especially data frames; matrices and lists don’t come up often in data visualization. Get familiar with R classes: integer, numeric, character, and logical. Understand how factors work; they are very important for graphing. Tidy up (r4ds) – Install the tidyverse, and get familiar with what it is. We will discuss differences between base R and the tidyverse in class. Learn ggplot2 basics (r4ds) – In class we will study the grammar of graphics on which ggplot2 is based, but it will help to familiarize yourself with the syntax in advance. Avail yourself of the “Data Visualization with ggplot2” cheatsheet by clicking “Help” “Cheatsheets…” within RStudio. Learn some RMarkdown – For this class you will write assignments in R Markdown (stored as .Rmd files) and then render them into pdfs for submission. You can jump right in and open a new R Markdown file (File &gt; New File &gt; R Markdown…), and leave the Default Output Format as HTML. You will get a R Markdown template you can tinker with. Click the “knit” button and see what happens. For more detail, watch the RStudio webinar Getting Started with R Markdown Use RStudio projects (r4ds) – If you haven’t already, drink the Kool-Aid. Make each problem set a separate project. You will never have to worry about getwd() or setwd() again because everything will just be in the right places. Or watch the webinar: “Projects in RStudio” Learn the basic dplyr verbs for data manipulation (r4ds) – Concentrate on the main verbs: filter() (rows), select() (columns), mutate(), arrange() (rows), group_by(), and summarize(). Learn the pipe %&gt;% operator. Know how to tidy your data – The pivot_longer() function from the tidyr package – successor to gather() – will help you get your data in the right form for plotting. More on this in class. Check out these super cool animations, which follow a data frame as it is transformed by tidyr functions. 2.2 Troubleshooting 2.2.1 Document doesn’t knit Normally an error message will display in the R Markdown section pointing to some lines with specific reasons. Try Googling as your first option and if not finding a solution, leave a post on ed discussion. 2.2.2 Functions stop working Strange behavior from functions that previously worked are often caused by function conflicts. This can happen if you have two packages loaded with the same function names. To indicate the proper package, namespace it. Conflicts commonly occur with select and filter and map. If you intend the tidyverse ones use: dplyr::select, dplyr::filter and purrr::map. Some other culprits: dplyr::summarise() and vcdExtra::summarise() ggmosaic::mosaic() and vcd::mosaic() leaflet::addLegend() and xts::addLegend() dplyr::select and MASS::select 2.3 Tips &amp; tricks 2.3.1 knitr Upon creating a new R markdown file, you should always notice a section like this: {r setup, include=False} knitr::opts_chunk$set(echo = TRUE) The chunk options refer to the first line and you can add some of the following options: {r setup, include=False, warning=False, message=False, cache=True} knitr::opts_chunk$set(echo = TRUE) warning=FALSE - Suppress warnings message=FALSE – Suppress messages, especially useful when loading packages cache=TRUE – only changed chunks will be evaluated, be careful though since changes in dependencies will not be detected. 2.3.2 Sizing figures Always use chunk options to size figures. You can set a default size in the YAML at the beginning of the .Rmd file as so: output: pdf_document: fig_height: 3 fig_width: 5 Another method is to click the gear ⚙️ next to the Knit button, then Output Options…, and finally the Figures tab. Then as needed override one or more defaults in particular chunks: {r, fig.width=4, fig.height=2} Figure related chunk options include fig.width, fig.height, fig.asp, and fig.align; there are many more. 2.3.3 R studio keyborad shortcuts Insert R chunk - option-command-i (Mac) - ctrl+alt+I (Windows) ```{r} ``` Insert %&gt;% (“the pipe”): shift-command(ctrl)-M Mac/Windows Comment/Uncomment lines shift-command(ctrl)-C Mac/Windows Knit Document shift-command(ctrl)-K Mac/Windows For more shortcuts, refer here 2.3.4 Viewing plots in plot window Would you like your plots to appear in the plot window instead of below each chunk in the .Rmd file? Click ⚙️ and then Chunk Output in Console. 2.3.5 Adding figures and links Add images ![DESCRIPTION HERE](PATH HERE) Add links: The text in the content column will act as a hyperlink [CONTENT HERE](LINK HERE) Note: Do not use these in r chunks as they will not work. "],["learning-ggplot2.html", "Chapter 3 Learning ggplot2 3.1 Getting started 3.2 Default part: layer 3.3 Customized parts 3.4 Resources for ggplot2", " Chapter 3 Learning ggplot2 3.1 Getting started Hopefully, most of you already have experiences in plotting basic R graphics. In this Chapter, you will be briefly introduced one of the most powerful plotting packages in R: ggplot2 with it’s basic grammar and functions. To start, install ggplot2 in the console or in R chunk. install.packages(&#39;ggplot2&#39;) 3.2 Default part: layer For many R beginners, the question is always like: why is ggplot? One remarkable feature of ggplot2 is having an underlying grammar which enables you to compose graphs by combining different components. You can easily create novel graphics by adding ggplot2 functions to meet your needs based on your data. By definition of the grammar of graphics, the most important features are data and mapping in the layers and that’s where we are getting started. library(ggplot2) ggplot(data = iris) + #Data part geom_point(aes(Sepal.Length, Sepal.Width)) #Mapping part The most important part of all plots is data, which includes the information you want to visualize. Based on that, the next step is to decide its mapping, which determine how the data’s variable are mapped to aesthetic attributes on a graphic. Since data is independent from the other elements, you can always add several layers of data into the same ggplot while keeping the other components the same. ggplot(data = iris) + #Data part geom_point(aes(Petal.Length, Petal.Width)) + #layer 1 with mapping geom_point(aes(Sepal.Length, Sepal.Width), color=&#39;red&#39;) #layer 2 with a different mapping 3.3 Customized parts The following picture shows the order of ggplot functions: For more function order suggestions and auto-correction when writing your own ggplot2 functions, please refer to ggformat addin created by Joyce. 3.3.1 Geometric object, statistical transformation and position adjustment Geometric object, Statistical transformation and Position adjustment are components that can be customized in each layer. Geometric objects geoms control the type of plot you create. Different types of plot have different aesthetics features. For example, a point geom has position, color, shape, and size aesthetics. You should first decide which kind of plot better explains the data before choosing geoms and use help function to check what aesthetics can be modified to achieve your desired effects. A statistical transformation stat transforms the data. And Position adjustment is applied when you need to adjust the position of elements on the plot for dense data, otherwise data points might obscure one another. ggplot(data = iris) + geom_histogram(mapping=aes(x=Petal.Length, fill=Species), stat = &#39;bin&#39;,position = &#39;stack&#39;) 3.3.2 Scale A scale controls how data is mapped to aesthetic attributes, so one scale for one layer. ggplot(data = iris) + geom_histogram(mapping=aes(x=Petal.Length, fill=Species), stat = &#39;bin&#39;,position = &#39;stack&#39;) + scale_x_continuous(limits = c(0, 10)) + scale_y_continuous(limits = c(0, 50)) 3.3.3 Coordinate system A coordinate system coord maps the position of objects onto the plane of the plot, and controls how the axes and grid lines are drawn. One ggplot can only have one coord ggplot(data = iris) + geom_histogram(mapping=aes(x=Petal.Length, fill=Species), stat = &#39;bin&#39;,position = &#39;stack&#39;) + coord_polar() 3.3.4 Faceting Faceting can be used to split the data up into subsets of the entire dataset. ggplot(data = iris) + geom_histogram(mapping=aes(x=Petal.Length), stat = &#39;bin&#39;) + facet_wrap(iris$Species) 3.3.5 Labels Labels include titles, labels for x,y axis and annotates. Good graphics also need to give clear information by using labels to tell readers’ of the background knowledge of your data. ggplot(data = iris) + geom_histogram(mapping=aes(x=Petal.Length, fill=Species), stat = &#39;bin&#39;,position = &#39;stack&#39;) + ggtitle(&#39;Stacked petal length of different species&#39;) + xlab(&#39;Length of Petal&#39;) 3.4 Resources for ggplot2 For more implementations and examples, one easiest way is referring to the ggplot2 Cheatsheets provided by R. Follow the steps shown below and you can find the cheat-sheets in your RStudio. The cheat-sheets clearly list the basic components of a ggplot where you can customize your unique plot by choosing different functions. If you are seeking for more detailed explanations and examples with real datasets, here are some useful links for you: ggplot2: Elegant Graphics ggformat "],["unidimensional-continuous-variables.html", "Chapter 4 Unidimensional continuous variables 4.1 Histogram 4.2 Boxplots 4.3 Ridgeline plot 4.4 Normal distribution", " Chapter 4 Unidimensional continuous variables In this chapter, we will demonstrate graphs with unidimensional continuous variables only using ggplot2. 4.1 Histogram 4.1.1 Basics and implications We will start with an easy example. library(ggplot2) library(gridExtra) #Example data x &lt;- c(50, 51, 53, 55, 56, 60, 65, 65, 68) #Stored as a dataframe df &lt;- data.frame(x) ggplot(df, aes(x)) + ggtitle(&quot;Histogram of x with ggplot2&quot;) + geom_histogram(color = &quot;blue&quot;, fill = &quot;lightBlue&quot;, binwidth = 5, center = 52.5) In this example, we used geom_histogram to create a histogram on variable x. We can see that it is quick to make and does not need much pre-processing. Moreover, Histograms show data’s empirical distribution within a set of intervals and we suggest using it as a one of the first steps to understand your data. Note: as shown above, ggplot expects a dataframe, so make sure you do not throw a vector into ggplot. 4.1.2 Types of histograms The y-scale of histograms can be represented in a variety of ways to express different results: Frequency or count: y = number of values that fall in each bin ggplot(finches, aes(x = Depth)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;,binwidth = 0.5,boundary = 6) + ggtitle(&quot;Frequency histogram&quot;) Cumulative frequency: y = total number of values &lt;= (or &lt;) right boundary of bin ggplot(finches, aes(x = Depth)) + geom_histogram(aes(y=cumsum(..count..)),color=&quot;blue&quot;,fill=&quot;lightblue&quot;,binwidth = 0.5, boundary = 6) + ggtitle(&quot;Cumulative frequency histogram&quot;) + xlab(&quot;Cumulative frequency&quot;) Density: y = relative frequency / binwidth ggplot(finches, aes(x = Depth)) + geom_histogram(aes(y=..density..),color=&quot;blue&quot;,fill=&quot;lightblue&quot;,binwidth = 0.5, boundary = 6) + ggtitle(&quot;Density histogram&quot;) 4.1.3 Parameters for geom_histogram 4.1.3.1 Bin boundaries Be mindful of the boundaries of the bins and whether a point will fall into the left or right bin if it is on a boundary. You can use the parameter closed to control the intervals. p1 &lt;- ggplot(df, aes(x)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;, binwidth = 5, center = 52.5, closed=&quot;left&quot;) + ggtitle(&quot;Left closed graph&quot;) p2 &lt;- ggplot(df, aes(x)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;, binwidth = 5, center = 52.5, closed=&quot;right&quot;) + ggtitle(&quot;Right closed graph&quot;) grid.arrange(p1, p2, ncol = 2) 4.1.3.2 Bin numbers #Default / Only adding some styles to make graph consistent ggplot(finches, aes(x = Depth)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;) + ggtitle(&quot;Default with pop-up about bin number&quot;) We start by passing no parameters into geom_histogram and you will notice a pop-up saying that the default number of bins is 30. We see that the graph is not ideal with some gaps. There are two ways to modify the number of bins: specify the width explicitly with binwidth or provide the desired number of bins with bins. Consider the following modifications: # using binwidth p3 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;,binwidth = 0.5, boundary = 6) + ggtitle(&quot;Changed binwidth value&quot;) # using bins p4 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;,bins = 15, boundary = 6) + ggtitle(&quot;Changed bin value&quot;) # format plot layout grid.arrange(p3, p4, ncol = 2) Note: There is no gold standard on the number of bins, so try different numbers to generate best results. 4.1.3.3 Bin alignment Consider this comparison p5 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;,binwidth = 0.5) + ggtitle(&quot;Without alignment&quot;) p6 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(color=&quot;blue&quot;,fill=&quot;lightblue&quot;,bins = 15, boundary = 6) + ggtitle(&quot;With alignment&quot;) grid.arrange(p5, p6, ncol = 2) Notice that the boundary of bins does not start at an axis and the only difference in the code is the removal of boundry. To control the position of bins, we can use either parameter center or boundary. You can use boundary to specify the endpoint of any bin or center to specify the center of any bin and ggplot2 will be able to calculate where to place the rest of the bins. (Also, notice that when the boundary was changed, the number of bins got smaller by one. This is because by default the bins are centered and go over/under the range of the data.) In the above example, we specify boundary to be 6. We can see the first bin starts at 6 and the position of other bins are calculated based on the binwidth 0.5. 4.1.4 Interactive histograms with ggvis The ggvis package is not currently in development, but does certain things very well, such as adjusting parameters of a histogram interactively while coding. If you are interested, refer here. 4.2 Boxplots 4.2.1 Single boxplot A boxplot is one of the simplest ways of representing a distribution of a continuous variable (Never use boxplots for categorical data). It consists of two parts: box and whiskers. Let’s starting with a simple example: single boxplot. ggplot(chickwts, aes(x=weight)) + geom_boxplot() + ggtitle(&quot;Boxplot of chicken weights&quot;) Here as you can see, boxplots provide a ton of information for a single chart. Boxplots tell you whether the variable is normally distributed, or if the distribution is skewed in either direction. You can also easily spot the outliers, which always helps. 4.2.2 Multiple boxplots Next, what if you want to compare the distributions between multiple classes? Here, you can create a multiple boxplot. But remember, your data frame needs to be tidy, that is you need to have a column with levels of the grouping variable. It can be be factor, character, or integer class. The following example still use the chickwts dataset. We compare the distributions of weight between different feed(which is a column with six factor levels). ggplot(chickwts, aes(x=reorder(feed, -weight, median),y=weight)) + geom_boxplot() + ggtitle(&quot;Multiple boxplots of chicken weights according to feed type&quot;) + labs(y=&quot;Weight&quot;, x=&quot;Feed Type&quot;) Note. Usually in a boxplot, the boxes should be reordered so that there will be a decreasing order of the class medians from left to right. Often you want boxplots to be horizontal. Super easy to do in ggplot2: just tack on + coord_flip() and remove the - from the reordering so that the factor level with the highest median will be on top: ggplot(chickwts, aes(x=reorder(feed, weight, median),y=weight)) + geom_boxplot() + coord_flip() + ggtitle(&quot;Multiple boxplots of chicken weights according to feed type&quot;) + labs(y=&quot;Weight&quot;, x=&quot;Feed Type&quot;) 4.2.3 Additional resources Tukey, John W. 1977. Exploratory Data Analysis. Addison-Wesley. (Chapter 2): the primary source in which boxplots are first presented. Article on boxplots with ggplot2: An excellent collection of code examples on how to make boxplots with ggplot2. Covers layering, working with legends, faceting, formatting, and more. If you want a boxplot to look a certain way, this article will help. Boxplots with plotly package: boxplot examples using the plotly package. These allow for a little interactivity on hover, which might better explain the underlying statistics of your plot. ggplot2 Boxplot: Quick Start Guide: Article from STHDA on making boxplots using ggplot2. Excellent starting point for getting immediate results and custom formatting. Hadley Wickhan and Lisa Stryjewski on boxplots: good for understanding basics of more complex boxplots and some of the history behind them. 4.3 Ridgeline plot 4.3.1 Basics and implications Ridgeline plots can be used when a number of data segments have to be plotted on the same horizontal scale. It is presented with slight overlap. Ridgeline plots are very useful to visualize the distribution of a categorical variable over time or space. A good example using ridgeline plots will be a great example is visualizing the distribution of salary over different departments in a company. Consider the following example: library(ggridges) library(forcats) world &lt;- read.csv(&quot;countries2012.csv&quot;) ggplot(world, aes(x = GDP, y = reorder(CONTINENT, -GDP,median))) + geom_density_ridges(fill = &quot;blue&quot;) + ggtitle(&quot;2012 continental GDP&quot;) + ylab(&quot;Continent&quot;) ggridge uses two main geoms to plot the ridgeline density plots: geom_density_ridges and geom_ridgeline. They are used to plot the densities of categorical variable factors and see their distribution over a continuous scale. 4.3.2 Create better visuals ggplot(world, aes(x = GDP, y = reorder(CONTINENT, GDP,median))) + geom_density_ridges(fill = &quot;blue&quot;,alpha = .5, scale = 1.2) + ggtitle(&quot;2012 continental GDP&quot;) + ylab(&quot;Continent&quot;) In this example, we added parameter scale and alpha to control overlaps between ridges. Scale defines how much the peak of the lower curve touches the curve above and alpha controls transparency. Note that the curves are ordered from lowest median GDP on the bottom (Africa) to highest on the top (Europe). 4.3.3 Additional resources Introduction to ggridges: An excellent collection of code examples on how to make ridgeline plots with ggplot2. Covers every parameter of ggridges and how to modify them for better visualization. If you want a ridgeline plot to look a certain way, this article will help. Article on ridgeline plots with ggplot2: Few examples using different examples. Great for starting with ridgeline plots. History of Ridgeline plots: To refer to the theory of ridgeline plots. 4.4 Normal distribution When encountering data that seems to be normally distributed, you may want to overlay a normal curve. There are many ways to draw a normal curve and we introduce one here: ggplot(finches, aes(x = Depth)) + geom_histogram(aes(y=..density..),color=&quot;blue&quot;,fill=&quot;lightblue&quot;,binwidth = 0.5) + stat_function(fun=dnorm, col = &quot;red&quot;,args=list(mean(finches$Depth),sd(finches$Depth))) + ggtitle(&quot;Normal curve overlaid&quot;) In some situations you might want to draw separate normal curves after faceting on a categorical variable. Simply using stat_function will not generate the desired result. Consider the following examples, where normal curves were created for four plots using a single stat_function. As first glance, a normal curve appears in all of the plots. However, if you look closely, all the normal curves are actually the same one and generated on the whole dataset. In such situation, we suggest drawing each graph separately and combine them. "],["unidimensional-categorical-variables.html", "Chapter 5 Unidimensional categorical variables 5.1 Bar plot 5.2 Cleveland dot plot", " Chapter 5 Unidimensional categorical variables In real-world datasets, categorical features are quite common but tricky during both the data pre-processing and visualization process. In this chapter, we will demonstrate several plotting options for the uni-dimensional categorical variables with ggplot. 5.1 Bar plot There are two types of uni-dimensional categorical variables: nominal and ordinal. Here you will be shown how these variables should be plotted differently using bar plot under the same dataset. 5.1.1 Nominal data Nominal data is data with no fixed category order and should be sorted from highest to lowest count (left to right, or top to bottom) By default, R always sorts levels in alphabetical order. To reorder it by a sorted value, you can try fct_reorder , fct_rev, fct_relevel in the forcats package library(vcdExtra) library(ggplot2) library(forcats) library(dplyr) Accident %&gt;% group_by(mode) %&gt;% summarise(freq = sum(Freq)) %&gt;% ggplot(aes(x=fct_reorder(mode,freq,.desc = TRUE),y=freq)) + geom_bar(stat = &quot;identity&quot;,fill = &quot;cornflowerblue&quot;) + ggtitle(&quot;Number of people with different modes in accident&quot;) + xlab(&quot;&quot;) + theme(panel.grid.major.x = element_blank()) … or top to bottom Accident %&gt;% group_by(mode) %&gt;% summarise(freq = sum(Freq)) %&gt;% ggplot(aes(x=fct_rev(fct_reorder(mode,freq,.desc = TRUE)),y=freq)) + geom_bar(stat = &quot;identity&quot;,fill = &quot;cornflowerblue&quot;) + ggtitle(&quot;Number of people with different modes in accident&quot;) + coord_flip() + xlab(&quot;&quot;) + theme(panel.grid.major.x = element_blank()) 5.1.2 Ordinal data Ordinal data is data having a fixed category order and need to sort it in logical order of the categories (left to right) Accident %&gt;% group_by(age) %&gt;% summarise(freq = sum(Freq)) %&gt;% ggplot(aes(x=age,y=freq)) + geom_bar(stat = &quot;identity&quot;,fill = &quot;cornflowerblue&quot;) + ggtitle(&quot;Number of people of different ages in accident&quot;) + xlab(&quot;&quot;) + theme(panel.grid.major.x = element_blank()) Sort in logical order of the categories (starting at bottom OR top) Accident %&gt;% group_by(age) %&gt;% summarise(freq = sum(Freq)) %&gt;% ggplot(aes(x=age,y=freq)) + geom_bar(stat = &quot;identity&quot;,fill = &quot;cornflowerblue&quot;) + ggtitle(&quot;Number of people of different ages in accident&quot;) + xlab(&quot;&quot;) + coord_flip() + theme(panel.grid.major.x = element_blank()) 5.2 Cleveland dot plot Cleveland dot plot is a good alternative to bar plots, making plots more readable and comparable even with more data. Similarly, we also need to reorder the categorical variables just like what we’ve done for nominal bar plot. library(Lock5withR) ggplot(USStates, aes(x = IQ, y = fct_reorder(State, IQ))) + geom_point(color = &quot;blue&quot;) + ggtitle(&quot;Avg. IQ for US states&quot;) + ylab(&quot;&quot;) + theme_linedraw() 5.2.1 Cleveland dot plot with multiple dots Sort by Obese Rate library(tidyr) USStates %&gt;% select(&#39;State&#39;,&#39;Obese&#39;,&#39;HeavyDrinkers&#39;) %&gt;% gather(key=&#39;type&#39;,value=&#39;percentage&#39;,Obese,HeavyDrinkers) %&gt;% ggplot(aes(x=percentage, y=fct_reorder2(State,type==&#39;Obese&#39;,percentage,.desc=FALSE), color = type)) + geom_point() + ggtitle(&quot;Obese rate &amp; heavy drinker rate in US&quot;) + ylab(&quot;&quot;) + theme_linedraw() 5.2.2 Cleveland dot plot with facets You can split the graph into small multiples using facet_grid(). ggplot(USStates, aes(x = IQ, y = reorder(State, IQ))) + geom_point(color = &quot;blue&quot;) + facet_grid(Pres2008 ~ ., scales = &quot;free_y&quot;, space = &quot;free_y&quot;) + ggtitle(&#39;IQ of US state residents facet by Pres2008&#39;) + xlab(&quot;IQ&quot;) + ylab(&#39;&#39;) + theme_linedraw() + theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank()) "],["working-with-factors.html", "Chapter 6 Working with factors", " Chapter 6 Working with factors "],["data-transformation.html", "Chapter 7 Data transformation 7.1 What is tidy data? 7.2 pivot_longer 7.3 pivot_wider 7.4 Basic transformation functions", " Chapter 7 Data transformation Plotting a graph is easy. You just need to find the right library with the right function. However, it is sometimes not so easy to get your data into the form desired to generate a graph. In this chapter, we will cover some basic techniques in tidying data with ggplot2. 7.1 What is tidy data? Here’s the definition of Tidy Data given by Hadley Wickham: A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. In tidy data: Each variable forms a column. Each observation forms a row. Each observational unit forms a value in the table. See r4ds on tidy data for more info. What are the advantages of tidy data? Uniformity : It is easier to learn the tools that work with the data because they have a consistent way of storing data. Most built-in R functions work with vectors of values. Thus, having variables as columns/vectors allows R’s vectorized nature to shine. Take a look at the following data and can you tell whether this data is messy or not? ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 In this data set,all the variables are parameters of cars. This means that they are not different variables, but are values of a common variable. To transform the data, we use pivot_longer. 7.2 pivot_longer mtcars %&gt;% rownames_to_column(&quot;carname&quot;) %&gt;% pivot_longer(cols = !carname, names_to = &quot;Parameters&quot;,values_to = &quot;value&quot;) %&gt;% head() ## # A tibble: 6 × 3 ## carname Parameters value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mazda RX4 mpg 21 ## 2 Mazda RX4 cyl 6 ## 3 Mazda RX4 disp 160 ## 4 Mazda RX4 hp 110 ## 5 Mazda RX4 drat 3.9 ## 6 Mazda RX4 wt 2.62 Follow the simple two steps: Identify the column you want to keep as is. In this case, we want all variables to match car names. Additionally, notice that in the original data set, carname acts as the index of the data set. You would want to convert the index to a column using rownames_to_column. Create meaningful names for the two new columns. In our case, straightforwardly, column names go into parameters and corresponding values go into value. 7.3 pivot_wider pivot_wider is just the opposite of pivot_longer. Using pivot_wider, we can transform our tidy data back into the messy form as all distinct values in Parameters will become column names. pivot_wider is often used in the case such that one observation being recorded over multiple rows. Consider the following example: ## # A tibble: 4 × 3 ## Country Type Number ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 USA Case 4 ## 2 USA Death 3 ## 3 Canada Case 2 ## 4 Canada Death 1 example %&gt;% pivot_wider(names_from = Type, values_from = Number) ## # A tibble: 2 × 3 ## Country Case Death ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 USA 4 3 ## 2 Canada 2 1 It would make much more sense if Case and Death are separate features. The main focus of this chapter is pivot_longer and pivot_wider. However, other fundamental functions in dplyr are also very important in manipulating your data set. In the following section, we will give an overview of the basics. 7.4 Basic transformation functions For the following sections, we will use data set biopsy from MASS for demonstration purpose. ## ID V1 V2 V3 V4 V5 V6 V7 V8 V9 class ## 1 1000025 5 1 1 1 2 1 3 1 1 benign ## 2 1002945 5 4 4 5 7 10 3 2 1 benign ## 3 1015425 3 1 1 1 2 2 3 1 1 benign ## 4 1016277 6 8 8 1 3 4 3 7 1 benign ## 5 1017023 4 1 1 3 2 1 3 1 1 benign ## 6 1017122 8 10 10 8 7 10 9 7 1 malignant 7.4.1 rename Upon getting the data, we noticed that the names of the columns are very vague. After reading the documentation, we wanted to change the names of the column so that the viewer gets a sense of the values they’re referring to. We use rename to modify the column names. biopsy_new &lt;- rename(biopsy, thickness = V1,cell_size = V2, cell_shape = V3, marg_adhesion = V4, epithelial_cell_size = V5, bare_nuclei = V6, chromatin = V7, norm_nucleoli = V8, mitoses = V9) head(biopsy_new) ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell_size ## 1 1000025 5 1 1 1 2 ## 2 1002945 5 4 4 5 7 ## 3 1015425 3 1 1 1 2 ## 4 1016277 6 8 8 1 3 ## 5 1017023 4 1 1 3 2 ## 6 1017122 8 10 10 8 7 ## bare_nuclei chromatin norm_nucleoli mitoses class ## 1 1 3 1 1 benign ## 2 10 3 2 1 benign ## 3 2 3 1 1 benign ## 4 4 3 7 1 benign ## 5 1 3 1 1 benign ## 6 10 9 7 1 malignant 7.4.2 select select is column-wise operation. Specifically, only the columns that are specified will be returned. In the biopsy data, we do not require the variables “chromatin” and “mitoses”. So, let’s drop them using a minus sign: #selecting all except the columns chromatin and mitoses biopsy_new &lt;- biopsy_new %&gt;% dplyr::select(-chromatin,-mitoses) head(biopsy_new,5) ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell_size ## 1 1000025 5 1 1 1 2 ## 2 1002945 5 4 4 5 7 ## 3 1015425 3 1 1 1 2 ## 4 1016277 6 8 8 1 3 ## 5 1017023 4 1 1 3 2 ## bare_nuclei norm_nucleoli class ## 1 1 1 benign ## 2 10 2 benign ## 3 2 1 benign ## 4 4 7 benign ## 5 1 1 benign 7.4.3 mutate The mutate function computes new variables from the already existing variables and adds them to the dataset. It gives information that the data already contained but was never displayed. The variable bare_nucleus contains the values from 1.00 to 10.00. If we wish to normalize the variable, we can use the mutate function: #normalize the bare nuclei values maximum_bare_nuclei&lt;-max(biopsy_new$bare_nuclei,na.rm=TRUE) biopsy_new &lt;- biopsy_new %&gt;% mutate(bare_nuclei=bare_nuclei/maximum_bare_nuclei) head(biopsy_new,5) ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell_size ## 1 1000025 5 1 1 1 2 ## 2 1002945 5 4 4 5 7 ## 3 1015425 3 1 1 1 2 ## 4 1016277 6 8 8 1 3 ## 5 1017023 4 1 1 3 2 ## bare_nuclei norm_nucleoli class ## 1 0.1 1 benign ## 2 1.0 2 benign ## 3 0.2 1 benign ## 4 0.4 7 benign ## 5 0.1 1 benign In some situations, your new variable might involve conditions. You can consider using case_when combined with mutate. 7.4.4 select Filter is a row-wise operation. It returns a modified copy that contains only certain rows. This function filters rows based on conditions supplied in its argument. The filter function takes the data frame as the first argument. The next argument contains one or more logical tests. The rows/observations that pass these logical tests are returned in the result of the filter function. For our example, say we only want the data of those tumor cells that have clump thickness greater than 6. biopsy_new &lt;- biopsy_new %&gt;% filter(thickness&gt;5.5) head(biopsy_new,5) ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell_size ## 1 1016277 6 8 8 1 3 ## 2 1017122 8 10 10 8 7 ## 3 1044572 8 7 5 10 7 ## 4 1047630 7 4 6 4 6 ## 5 1050670 10 7 7 6 4 ## bare_nuclei norm_nucleoli class ## 1 0.4 7 benign ## 2 1.0 7 malignant ## 3 0.9 5 malignant ## 4 0.1 3 malignant ## 5 1.0 1 malignant If you want to filter using multiple conditions, use logical operators: &amp;(And), |(Or). 7.4.5 arrange Arrange reorders the rows of the data based on their contents in the ascending order by default. Say in our example, the doctors would want to view the data in the order of the cell size of the tumor. #arrange in the order of V2:cell size head(arrange(biopsy_new,cell_size)) ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell_size ## 1 1050718 6 1 1 1 2 ## 2 1204898 6 1 1 1 2 ## 3 1223967 6 1 3 1 2 ## 4 543558 6 1 3 1 4 ## 5 63375 9 1 2 6 4 ## 6 752904 10 1 1 1 2 ## bare_nuclei norm_nucleoli class ## 1 0.1 1 benign ## 2 0.1 1 benign ## 3 0.1 1 benign ## 4 0.5 10 malignant ## 5 1.0 7 malignant ## 6 1.0 4 malignant In case you want your data in descending order, wrap your variable with desc(). 7.4.6 group_by and summarize The summarize function uses the data to create a new data frame with the summary statistics such as minimum, maximum, average, and so on. These statistical functions must be aggregate functions which take a vector of values as input and output a single value. The group_by function groups the data by the values of the variables. This, along with summarize, makes observations about groups of rows of the dataset. The doctors would want to see the maximum cell size and the thickness for each of the classes: benign and malignant. This can be done by grouping the data by class and finding the maximum of the required variables: biopsy_grouped &lt;- group_by(biopsy_new,class) summarize(biopsy_grouped, max(thickness), mean(cell_size), var(norm_nucleoli)) ## # A tibble: 2 × 4 ## class `max(thickness)` `mean(cell_size)` `var(norm_nucleoli)` ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 benign 8 2.67 5.93 ## 2 malignant 10 6.73 11.3 "],["two-continuous-variables.html", "Chapter 8 Two continuous variables 8.1 Scatterplot 8.2 Heatmaps", " Chapter 8 Two continuous variables In this chapter, we will look at techniques that explore the relationships between two continuous variables. 8.1 Scatterplot 8.1.1 Basics and implications For the following example, we use data set SpeedSki. library(GDAdata) library(ggplot2) ggplot(SpeedSki, aes(Year, Speed)) + geom_point() + labs(x = &quot;Birth year&quot;, y = &quot;Speed achieved (km/hr)&quot;) + ggtitle(&quot;Skiers by birth year and speed achieved&quot;) In our example, we simply use geom_point on variables Year and Speed to create the scatterplot. we try to capture if there is a relationship between the age of a player and the speed he/she can achieve. From the graph, it seems such relationship does not exist. Overall, scatterplots are very useful in understanding the correlation (or lack thereof) between variables. The scatterplot gives a good idea of whether that relationship is positive or negative and if there’s a correlation. However, don’t mistake correlation in a scatterplot for causation! 8.1.2 Overplotting In some situations a scatter plot faces the problem of overplotting as there are so many points overlapping. Consider the following example from class. To save time, we randomly sample 20% of the data in advance. library(dplyr) library(ggplot2movies) sample &lt;- slice_sample(movies,prop=0.2) ggplot(sample,aes(x=votes,y=rating)) + geom_point() + theme_classic() + ggtitle(&quot;Votes vs. rating&quot;) To create better visuals, we can use: Alpha blending - alpha=... Open circles - pch=21 smaller circles - size=... or shape=\".\" library(gridExtra) f1 &lt;- ggplot(sample,aes(x=votes,y=rating)) + geom_point(alpha=0.3) + theme_classic() + ggtitle(&quot;Alpha blending&quot;) f2 &lt;- ggplot(sample,aes(x=votes,y=rating)) + geom_point(pch = 21) + theme_classic() + ggtitle(&quot;Open circle&quot;) f3 &lt;- ggplot(sample,aes(x=votes,y=rating)) + geom_point(size=0.5) + theme_classic() + ggtitle(&quot;Smaller circle&quot;) grid.arrange(f1, f2, f3,nrow = 3) Other methods that directly deal with the data: Randomly sample data - as shown in the first code chunk using sample_n Subset - split data into bins using ntile(votes, 10) Remove outliers Transform to log scale 8.1.3 Interactive scatterplot You can create an interactive scatterplot using plotly. In the following example, we take 1% of the movie data set to present a better visual. We plotted the votes vs. rating and grouped by the year they are released. In this graph: You can hover on to the points to see the title of the movie You can double click on the year legend to look at a certain year You can zoom into a certain part of the graph to better understand the data points. library(plotly) sample2 &lt;- slice_sample(movies,prop=0.01) %&gt;% filter(year &gt; 2000) plot_ly(sample2, x = ~votes, y = ~rating, color = ~as.factor(year), text= ~title, hoverinfo = &#39;text&#39;) 8.1.4 Modifications 8.1.4.1 Contour lines Contour lines give a sense of the density of the data at a glance. For these contour maps, we will use the SpeedSki dataset. Contour lines can be added to the plot using geom_density_2d() and contour lines work best when combined with other layers ggplot(SpeedSki, aes(Year, Speed)) + geom_density_2d(bins=5) + geom_point() + ggtitle(&quot;Scatter plot with contour line&quot;) You can use bins to control the number of contour bins. 8.1.4.2 Scatterplot matrices If you want to compare multiple parameters to each other, consider using a scatterplot matrix. This will allow you to show many comparisons in a compact and efficient manner. For these scatterplot matrices, we use the movies dataset from the ggplot2movies package. As a default, the base R plot() function will create a scatterplot matrix when given multiple variables: sample3 &lt;- slice_sample(movies,prop=0.01) #sample data splomvar &lt;- sample3 %&gt;% dplyr::select(length, budget, votes, rating, year) plot(splomvar) While this is quite useful for personal exploration of a datset, it is not recommended for presentation purposes. Something called the Hermann grid illusion makes this plot very difficult to examine. 8.2 Heatmaps 8.2.1 Basics and implications In the following example, we still use the SpeedSki data set. ggplot(SpeedSki, aes(Year, Speed)) + geom_bin2d() To create a heatmap, simply substitute geom_point() with geom_bin2d(). Generally, heat maps are like a combination of scatterplots and histograms: they allow you to compare different parameters while also seeing their relative distributions. 8.2.2 Modifications For the following section, we introduce some variations on heatmaps. 8.2.2.1 Change number of bins / binwidth By default, geom_bin2d() use 30 bins. Similar to a histogram, we can change the number of bins or binwidth. ggplot(SpeedSki, aes(Year, Speed)) + geom_bin2d(binwidth = c(5,5)) + ggtitle(&quot;Changing binwidth&quot;) Notice we are specifying the binwidth for both x and y axis. 8.2.2.2 Combine with a scatterplot ggplot(SpeedSki, aes(Year, Speed)) + geom_bin2d(binwidth = c(10, 10), alpha = .4) + geom_point(size = 2) + ggtitle(&quot;Combined with scatterplot&quot;) 8.2.2.3 Change color scale You can change the continuous scale of color ggplot(SpeedSki, aes(Year, Speed)) + geom_bin2d() + ggtitle(&quot;Changing color scale&quot;) + scale_fill_viridis_c() 8.2.2.4 Hex heatmap One alternative is a hex heatmap. You can create the graph using geom_hex ggplot(SpeedSki, aes(Year, Speed)) + geom_hex(binswidth = c(10,10)) + ggtitle(&quot;Hex heatmap&quot;) 8.2.2.5 Alternative approach to color If you look at all the previous examples, you might notice that lighter points corresponds to more clustered points, which is somewhat counter-intuitive. The following exmaple suggest an alternative approach in color scale. ggplot(SpeedSki, aes(Year, Speed)) + geom_hex(bins=12) + scale_fill_gradient(low = &quot;grey&quot;, high = &quot;purple&quot;) + theme_classic(18) + ggtitle(&quot;Alternative approach to color&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
